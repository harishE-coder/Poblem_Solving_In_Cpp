# 2441\. Largest Positive Integer That Exists With Its Negative

## Problem Statement

Given an integer array `nums` that does not contain any zeros, find the **largest positive integer** `k` such that `-k` also exists in the array. If there is no such integer, return `-1`.

## Intuition

The problem asks for a matching pair $(k, -k)$ where $k$ is maximized.
By sorting the array first, the negative numbers move to the left (beginning) and positive numbers move to the right (end). This allows us to use the **Two Pointer** technique to scan from the extremes inward. Since the array is sorted, the largest possible candidates for $k$ are at the end of the array.

## Approach

1.  **Sort:** Sort the input vector `nums` in ascending order. This takes $O(N \log N)$ time.
2.  **Initialize Pointers:** Set `left` to the start of the array ($0$) and `right` to the end ($n-1$).
3.  **Iterate:** Loop while `left < right`:
      * Calculate `sum = nums[left] + nums[right]`.
      * **Match Found (`sum == 0`):** Since `nums[right]` is the largest available positive integer and we found its negation, return `nums[right]`.
      * **Negative dominant (`sum < 0`):** The absolute value of the negative number at `nums[left]` is larger than `nums[right]`. We need a smaller negative number (closer to zero), so increment `left`.
      * **Positive dominant (`sum > 0`):** The positive number at `nums[right]` is larger than the absolute value of `nums[left]`. We need a smaller positive number, so decrement `right`.
4.  **Fallback:** If the loop terminates without a match, return `-1`.

## Complexity Analysis

  * **Time Complexity:** $$O(N \log N)$$
      * Sorting the array takes $O(N \log N)$.
      * The two-pointer traversal takes $O(N)$ in the worst case.
      * The dominant term is sorting.
  * **Space Complexity:** $$O(1)$$or$$O(\log N)$$
      * Space depends on the implementation of `std::sort`. In C++, `std::sort` usually uses an introspective sort (QuickSort/HeapSort/InsertionSort mix), which takes $O(\log N)$ stack space.
      * We are not using any auxiliary data structures like Hash Maps or Sets.

## Code

```cpp
class Solution {
public:
    int findMaxK(vector<int>& nums) {
        // Step 1: Sort the array to order elements from smallest (negative) to largest (positive)
        sort(nums.begin(), nums.end());
        
        int left = 0;
        int right = nums.size() - 1;
        
        // Step 2: Two-pointer approach
        while (left < right) {
            int sum = nums[left] + nums[right];
            
            if (sum == 0) {
                // Found the pair (-k, k), return the positive value
                return nums[right];
            } 
            else if (sum < 0) {
                // Negative value is too "large" (e.g., -10 vs 5), move left pointer
                left++;
            } 
            else { // sum > 0
                // Positive value is too large (e.g., -3 vs 8), move right pointer
                right--;
            }
        }
        
        // Step 3: No pair found
        return -1;
    }
};
```

-----

Would you like to see the **O(N) time complexity** solution using a Hash Set (unordered\_set) instead of sorting?
