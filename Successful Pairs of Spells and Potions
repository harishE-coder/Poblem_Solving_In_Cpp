/*
Problem: Successful Pairs of Spells and Potions

Description:
Given two integer arrays spells and potions and a long long integer success, a pair (spell, potion)
is considered successful if spell * potion >= success. For each spell, return the number of
potions that form a successful pair with that spell. Return the answers in an array in the same order
as spells.

Constraints:
- 1 <= spells.length, potions.length <= 10^5
- 1 <= spells[i], potions[i] <= 10^5
- 1 <= success <= 10^10 (fits in 64-bit)

Approach / Explanation:
To count, sort the potions array once (O(m log m)). For each spell, compute the minimum potion value
'need' such that spell * potion >= success. To avoid floating-point precision issues use integer
ceil division: need = (success + spell - 1) / spell. Then use binary search (lower_bound) on the
sorted potions array to find the first potion >= need; the count is (m - pos).

Time complexity: O(m log m + n log m) where n = spells.size(), m = potions.size().

Example:
Input:
spells = [5, 1, 3]
potions = [1, 2, 3, 4, 5]
success = 7

Output: [4, 0, 3]

Explanation:
- For spell 5, need = ceil(7/5) = 2 -> potions >= 2 are [2,3,4,5] -> 4 successful pairs.
- For spell 1, need = 7 -> no potion >= 7 -> 0.
- For spell 3, need = ceil(7/3) = 3 -> potions >= 3 are [3,4,5] -> 3.
*/

#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        sort(potions.begin(), potions.end());
        vector<int> res;
        res.reserve(spells.size());

        for (int spell : spells) {
            if (spell == 0) { // defensive: avoid division by zero (if input allowed)
                res.push_back(0);
                continue;
            }
            long long need = (success + (long long)spell - 1) / (long long)spell; // integer ceil
            auto it = lower_bound(potions.begin(), potions.end(), need);
            res.push_back((int)(potions.end() - it));
        }
        return res;
    }
};